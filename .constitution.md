# Open Agent Kit (OAK) Constitution

## Metadata

- **Project:** open-agent-kit
- **Version:** 3.3.0
- **Status:** Adopted
- **Last Updated:** 2026-01-21
- **Author:** @sirkirby
- **Tech Stack:** Python 3.13+, Typer, Pydantic, Rich, Jinja2, ChromaDB, SQLite

**Purpose:** This document defines the **hard invariants** for designing, building, and maintaining Open Agent Kit (OAK). All agent instruction files must align with this constitution.

**What OAK is:** A local-first CLI tool for AI-powered development workflows. It ships agent-agnostic templates, rules, and tooling to help humans and coding agents build consistently.

**What OAK is not (non-goals):**

- Not an agent framework
- Not an agent replacement
- Not an agent orchestrator

---

## 1. Core Invariants (Hard Rules)

### 1.1 “Proper Engineering” Always

- Prefer correct foundations over shortcuts.
- Address root cause, not symptoms.
- If a change requires more work to be done “the right way,” do it. This project is built to be maintainable by a single engineer long-term.

### 1.2 Local-First (Meaningful Definition)

“Offline” in OAK means **AI and data workflows prefer local infrastructure**:

- Prefer **local LLMs** and **local embedding models** over cloud models.
- Prefer **local vector search** and **local transactional storage**:
  - **ChromaDB** for vector search
  - **SQLite** for transactional data

Network-required integrations (e.g., issue providers) are allowed, but **must not be required for core usage**.

### 1.3 Team Adoption, Local State

- OAK supports team-wide adoption through consistent rules/templates.
- OAK stores **user-local state** (agent sessions, code index, databases) that is **not committed to git**.
- Generated work products (docs/specs) should be safe to version-control; user-local indexes and sessions are not.

### 1.4 Idempotence by Default

Commands should be rerunnable safely.

- Re-running `oak init` should not break projects.
- `oak upgrade` should be safe to repeat.
- When overwriting is required, it must be explicit and explainable.

### 1.5 Templates Are Owned By OAK (Hard Rule)

- Templates shipped by OAK are **managed by OAK** and **overwritten on upgrade**.
- No user-owned template overrides. No “local template patching.” No precedence rules. OAK is the source of truth.

---

## 2. Golden Paths (How Changes Must Be Implemented)

Agents must follow these golden paths. If uncertain, **ask**. Do not freestyle.

### 2.1 Add a New Feature (Primary Golden Path)

Adding a feature may include:

- New CLI commands
- New templates
- New services/models
- Optional daemon support + UI + API surface (feature-dependent)
- Feature-specific storage (SQLite/ChromaDB) and migrations (feature-managed when appropriate)

**Must follow:**

- Use the **vertical slice** pattern (feature code co-located).
- Use existing features as anchors for structure and conventions.
- Prefer extension through new services + registration over “if/else sprawl.”

### 2.2 Add a New Agent (Primary Golden Path)

Adding an agent requires:

- Understanding the agent’s capabilities and constraints (install/remove, command formats, interaction style).
- Updating feature support appropriately based on those capabilities.

**Must follow:**

- Implement like an existing agent with **similar capabilities**.
- If capability mapping is unclear: **stop and ask** (do not invent assumptions).

### 2.3 Add a Command

- Commands should remain thin: parse inputs, call services, render output.
- Services own business logic.

### 2.4 Add a Template

- Templates must be generated from canonical sources in the package.
- Templates must remain deterministic and upgradeable.

### 2.5 Add a Config Value

- Prefer type-safe config (Pydantic models).
- Do not introduce ad-hoc dict/YAML handling unless there is a strong reason and it is documented.

---

## 3. Architecture Rules

### 3.1 Layering

OAK follows a layered architecture:

- **CLI Layer (Typer):** user entry points, flags, dispatch
- **Command Layer:** command implementations
- **Service Layer:** business logic
- **Model Layer (Pydantic):** typed data structures
- **Storage Layer:** filesystem, YAML, SQLite, ChromaDB

### 3.2 Vertical Slice Features

Features are self-contained packages under `src/open_agent_kit/features/<feature_name>/`:

- Feature services live with feature code.
- Feature manifests declare defaults and install assets.
- Feature-specific storage logic is owned by the feature.

### 3.3 “Extend, Don’t Patch”

When adding functionality:

- Prefer **new service + registration** or **new strategy** rather than modifying unrelated code paths.
- Avoid growing god-services and mega-constants files. Refactor early.

---

## 4. No-Magic-Literals (Zero Tolerance)

**No literal strings or numbers in code.** This includes tests.

Rationale: literals create silent drift and hard-to-find bugs.

### 4.1 Where Values Must Live

Default approach: centralize in `constants.py` until it becomes unwieldy; then decompose by domain.

- Start simple (central constants), evolve into domain modules when necessary.
- Decomposition is allowed, but the rule remains: **no literals in code**.

Recommended decomposition pattern when `constants.py` becomes too large:

- `config/paths.py` — file/dir names and paths
- `config/messages.py` — user-facing text
- `config/settings.py` — runtime settings (env vars via Pydantic Settings)
- `models/enums.py` — type-safe enums for statuses/keys
- `constants/*.py` — domain constants (validation, agent configs, feature registry, etc.)

### 4.2 Type Safety Preferred

- Prefer Pydantic models and enums over raw dicts and string lists.
- If a value crosses a boundary (CLI ↔ config ↔ storage ↔ templates), it must be centralized and typed.

---

## 5. CLI Behavior and Output

### 5.1 Human vs Agent Output

- Humans default to Rich, friendly CLI output.
- Agent-facing commands may return more efficient structured output (e.g., JSON) **when it improves agent reliability**, but `--json` is not a global requirement.

### 5.2 Logging and Observability (Hard Requirement)

- Logging must be consistent, structured, and leveled for both humans and agents.
- Prefer predictable error output with enough context to debug without guesswork.
- If error codes are introduced, they must be consistent and centrally managed.

### 5.3 Error Handling

- Error output must be actionable: what failed + why + what to do next.
- Prefer stable error messages via centralized message constants (no inline strings).

---

## 6. Upgrade, Migrations, and Data Evolution

### 6.1 Upgrade Must Be Explainable (Hard Rule)

- `oak upgrade` must support a dry-run mode that explains what will happen.
- Users should be able to understand what changes are going to be applied before they commit.

### 6.2 What “Migrations” Mean in OAK
There are two categories of migration:

1) **Init/Upgrade System Migrations (OAK-managed)**

- Reserved for major changes that affect what OAK installs into the user’s project.
- Use existing migrations as anchors and follow established patterns.

2) **Feature-Managed Migrations**

- Some features (e.g., codebase intelligence) may manage their own schema/data migrations after upgrade.
- Feature-managed migrations must be automatic, safe, and testable.

Rule of thumb:

- If it mutates or restructures **installed user project assets** in a major way → OAK migration.
- If it evolves **feature-owned databases/data** → feature-managed migration.

---

## 7. Quality Gates and Definition of Done (DoD)

### 7.1 Hard Gate

- `make check` must pass for every change.

### 7.2 Definition of Done (Non-Negotiables)

For every change:

- `make check` passes (lint, format, typing, tests, etc.)
- README is reviewed and updated if behavior, install, or workflows changed
- Documentation is updated to prevent drift:
  - If you touch a feature, update the feature’s doc (or create one if missing)
- No “drive-by” changes without docs/tests when behavior changes
- No literals added anywhere (including tests)

---

## 8. Deviation Process (Narrow Lanes)

These are hard rules with narrow lanes for deviation.

### 8.1 When Unsure: Ask

If a rule seems to conflict with the change:
- Stop and ask rather than guessing.

### 8.2 If a New Pattern Is Adopted

If you deviate because a better pattern is needed:
- Update this constitution (or the relevant playbook) so the new pattern becomes the default going forward.

### 8.3 Where Decisions Live

- Formal design decisions → RFC
- Less formal decisions → feature doc or project doc
- All deviations should result in clearer future rules (reduce repeat friction)

---

## 9. Canonical Project Layout (Reference)

OAK source layout and generated user layout are defined in the project docs.
This constitution defines invariants; detailed playbooks live in:

- `docs/development/features.md`
- `docs/development/migrations.md`
- `docs/issue-workflow.md`

---

**This constitution is the source of truth for how OAK is built. Agents and contributors must follow it.**
